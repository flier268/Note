<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learning Typescript 2021-01-19</title>
      <link href="/Note/2021/01/18/Learning%20Typescript%202021-01-19/"/>
      <url>/Note/2021/01/18/Learning%20Typescript%202021-01-19/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-38-戰線擴張・模擬戰-—-UBike-地圖-X-Webpack-環境建構-TypeScript-Webpack-Integration"><a href="#Day-38-戰線擴張・模擬戰-—-UBike-地圖-X-Webpack-環境建構-TypeScript-Webpack-Integration" class="headerlink" title="Day 38. 戰線擴張・模擬戰 — UBike 地圖 X Webpack 環境建構 - TypeScript Webpack Integration"></a><a href="https://ithelp.ithome.com.tw/articles/10224782">Day 38. 戰線擴張・模擬戰 — UBike 地圖 X Webpack 環境建構 - TypeScript Webpack Integration</a></h2><p>本篇文章在教如何使用webpack打包typescript專案，webpack使用各種<code>Loader</code>來載入網頁所需的各種檔案，諸如<code>css-loader</code>, <code>sass-loader</code>，這次要用的則是<code>ts-loader</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化</span><br><span class="line">npm init -y</span><br><span class="line">tsc --init</span><br><span class="line">npm i webpack webpack-cli</span><br><span class="line">npm i ts-loader</span><br></pre></td></tr></table></figure><p>本地安裝typescript</p><ul><li>Webpack不會從global的npm模組參照<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript</span><br></pre></td></tr></table></figure><code>tsconfig.json</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* 略... */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">/* 略... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>建立<code>webpack.config.js</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">enrty: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">extensions: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">path: path.resolve(_dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>entry</code> 部分代表的是 Webpack 要打包的檔案輸入位置，也就是 <code>./src/index.ts</code> 檔</li><li><code>module</code> 裡面通常都是放置 Loader 相關設定 —— 其中 TypeScript 相關檔案都會經由<code>ts-loader</code>進行編譯處理的動作</li><li><code>output</code> 則是設定 Webpack 打包過後的專案輸出點 —— 以上面的設定來說，它會把檔案打包到 <code>./dist</code> 資料夾內，並且取名為 <code>bundle.js</code></li></ul><p>接著，在<code>index.html</code>載入編譯出來的`bundle.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><code>webpack</code>可以使用<code>webpack -w</code>開啟Watch模式，只要專案一有變動，Webpack就會自動重新打包<br>但是，這樣子又需要同時開啟兩個終端機，分別執行<code>lite-server</code> &amp; <code>webpack -w</code>，所以，為了方便除錯，我們額外使用<code>concurrently</code>來同時執行這兩個指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i lite-server concurrently</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 略... */</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start:watch&quot;</span>: <span class="string">&quot;webpack -w&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start:serve&quot;</span>: <span class="string">&quot;lite-server&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;concurrently npm:start:*&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 略... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重點"><a href="#重點" class="headerlink" title="重點"></a>重點</h3><ul><li>必須要下載 typescript 模組到專案裡，因為 Webpack 的 ts-loader 必須仰賴專案內部的編譯器，而非全域</li><li>TypeScript 檔案對應的 Loader 是 ts-loader</li><li>通常使用 Webpack 時，就不太管 tsconfig.json 裡面的 outFile 這個選項，因為 Webpack 會幫你處理好整個打包流程，你也不需要再為其他模組規範擔心來擔心去的</li><li>記得啟動 tsconfig.json 裡跟語法或型別監測相關的設定 —— 例如 noImplicitAny 或 strictNullChecks</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2021-01-08</title>
      <link href="/Note/2021/01/07/Learning%20Typescript%202021-01-08/"/>
      <url>/Note/2021/01/07/Learning%20Typescript%202021-01-08/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-36-戰線擴張・戰線分散-X-組織集中-TypeScript-Namespaces-Import-Export-Mechanism"><a href="#Day-36-戰線擴張・戰線分散-X-組織集中-TypeScript-Namespaces-Import-Export-Mechanism" class="headerlink" title="Day 36. 戰線擴張・戰線分散 X 組織集中 - TypeScript Namespaces Import/Export Mechanism"></a><a href="https://ithelp.ithome.com.tw/articles/10223853">Day 36. 戰線擴張・戰線分散 X 組織集中 - TypeScript Namespaces Import/Export Mechanism</a></h2><ul><li>namespace是一個過時的用法，現在已經沒什麼人在用了，但是，還是要知道怎麼用，因為有很多舊專案使用namespace寫</li><li>用<code>outputFile</code>搭配<a href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html">Triple Slash Directive</a>可以將專案打包成單一檔案<br>  Example:  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;&lt;path-to-file&gt;&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Day-37-戰線擴張・第三方套件-X-支援的引入-3rd-Party-Package-amp-TypeScript-Declaration-File"><a href="#Day-37-戰線擴張・第三方套件-X-支援的引入-3rd-Party-Package-amp-TypeScript-Declaration-File" class="headerlink" title="Day 37. 戰線擴張・第三方套件 X 支援的引入 - 3rd-Party Package &amp; TypeScript Declaration File"></a><a href="https://ithelp.ithome.com.tw/articles/10224070">Day 37. 戰線擴張・第三方套件 X 支援的引入 - 3rd-Party Package &amp; TypeScript Declaration File</a></h2><ul><li>使用第三方套件的時候，套件不一定是用Typescript寫的，這時候需要<strong>型別定義與宣告檔</strong>來告訴Typescript這是什麼</li><li>如果沒有<strong>型別定義與宣告檔</strong>，雖然可以硬編譯(tsconfig.json的noEmitOnError != true)出結果，並且正確執行，但是卻卻會出現很多的錯誤訊息</li><li>臨時的解法是使用<code>declare</code><br>  以JQuery為例  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> $ : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>  可以直接寫在index.ts，但是建議建立一個JQuery.d.ts<ul><li>*.d.ts就是前面說的<strong>型別定義與宣告檔</strong></li></ul></li><li><strong>正確的</strong>做法是安裝相對應的Typescript定義套件，通常都在<code>@types\</code>下<ul><li>裡面通常只有定義檔，而沒有主要的程式碼，所以兩個都要安裝<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @types&#x2F;jquery</span><br><span class="line">npm i jquery</span><br></pre></td></tr></table></figure></li></ul></li><li>有的套件使用Typescript寫的，原本就包含.d.ts檔了，所以不需另外安裝，要依套件而定</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-31</title>
      <link href="/Note/2020/12/30/Learning%20Typescript%202020-12-31/"/>
      <url>/Note/2020/12/30/Learning%20Typescript%202020-12-31/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-35-戰線擴張・命名空間-X-組織分明-TypeScript-Namespaces-Introduction"><a href="#Day-35-戰線擴張・命名空間-X-組織分明-TypeScript-Namespaces-Introduction" class="headerlink" title="Day 35. 戰線擴張・命名空間 X 組織分明 - TypeScript Namespaces Introduction"></a><a href="https://ithelp.ithome.com.tw/articles/10223480">Day 35. 戰線擴張・命名空間 X 組織分明 - TypeScript Namespaces Introduction</a></h2><ul><li>namespace的主要功能在於<strong>避免全域的汙染</strong></li><li>相同名稱的namespace會互相合併</li><li>使用export的function/class/namespace才能從命名空間以外存取</li><li>相同名稱的命名空間會合併，但是…<ul><li>除了interface這種本來就有可融合特性的之外，名稱皆不允許重複</li><li>就算有相同的名稱，只要沒有export，一樣不能存取<br>  <img src="bf9e044d52184203bd9d1674606ee04b" alt="7cd3b8ae467fffc4580cfe39952e2731.png"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-30</title>
      <link href="/Note/2020/12/29/Learning%20Typescript%202020-12-30/"/>
      <url>/Note/2020/12/29/Learning%20Typescript%202020-12-30/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-34-戰線擴張・專案語法-X-嚴格把關-TypeScript-Compiler-Syntatic-Checks-Configurations"><a href="#Day-34-戰線擴張・專案語法-X-嚴格把關-TypeScript-Compiler-Syntatic-Checks-Configurations" class="headerlink" title="Day 34. 戰線擴張・專案語法 X 嚴格把關 - TypeScript Compiler Syntatic Checks Configurations"></a><a href="https://ithelp.ithome.com.tw/articles/10223400">Day 34. 戰線擴張・專案語法 X 嚴格把關 - TypeScript Compiler Syntatic Checks Configurations</a></h2><p>這篇一樣在講<code>tsconfig.json</code>的設定</p><ul><li><code>strickNullChecks</code>：檢查物件是否為null，如果是null但卻被使用，就判定為錯誤（遇到遲滯性指派）</li><li><code>noImplicitAny</code>：禁止隱性的<code>any</code>型態</li><li>strictFunctionTypes</li><li>strictBindCallApply</li><li>strictPropertyInitialization</li><li>noUnusedLocals —— 如果有變數沒有被使用就會出現警告</li><li>noUnusedParameters —— 如果函式裡的參數沒有被使用，就會發出警告</li><li>noImplicitReturns —— 如果函式裡有出現路徑是沒有回傳值就會發出警告</li><li>noFallthroughCasesInSwitch —— 每個 switch 裡面的 case 判斷敘述式一定要有 break 語法，不能有 case 沒有 break 以至於會執行到下一個 case</li><li>noImplicitThis —— this 如果被 TypeScript 判定為 any 型態時就會發出警告</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-29</title>
      <link href="/Note/2020/12/28/Learning%20Typescript%202020-12-29/"/>
      <url>/Note/2020/12/28/Learning%20Typescript%202020-12-29/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-30-機動藍圖・流言終結者-X-重新認識物件的複合-Favour-Object-Composition-Over-Class-Inheritance"><a href="#Day-30-機動藍圖・流言終結者-X-重新認識物件的複合-Favour-Object-Composition-Over-Class-Inheritance" class="headerlink" title="Day 30. 機動藍圖・流言終結者 X 重新認識物件的複合 - Favour Object Composition Over Class Inheritance"></a><a href="https://ithelp.ithome.com.tw/articles/10221357">Day 30. 機動藍圖・流言終結者 X 重新認識物件的複合 - Favour Object Composition Over Class Inheritance</a></h2><p>本篇實際上是在總結先前的策略模式，並證明網路上的大多數文章都是錯的<br><strong>最好的做法還是使用策略模式</strong></p><hr><h2 id="Day-31-戰線擴張・專案監控-X-編譯設定-TypeScript-Compiler-Compile-Configurations"><a href="#Day-31-戰線擴張・專案監控-X-編譯設定-TypeScript-Compiler-Compile-Configurations" class="headerlink" title="Day 31. 戰線擴張・專案監控 X 編譯設定 - TypeScript Compiler Compile Configurations"></a><a href="https://ithelp.ithome.com.tw/articles/10222025">Day 31. 戰線擴張・專案監控 X 編譯設定 - TypeScript Compiler Compile Configurations</a></h2><ul><li><code>lib</code>幫Typescript擴充額外的功能<blockquote><p>某些功能層面語法不能用的原因其實是因為沒有在tsconfig.json加入相對應的lib，導致typescript不認識他</p><ul><li>語法層面（Syntatic Aspect）泛指單純語法解析上的特點，通常語法是自然內建在編譯器的</li><li>功能層面（Utility Aspect）泛指可以藉由語法實踐的功能，並非內建在編譯器，通常會以函式庫（Library）的方式載入，或以 ECMAScript 的觀點來看 —— 以 Polyfill 的方式載入功能。    </li></ul></blockquote><ul><li>像Promise等<strong>功能層面</strong>的語法，需添加<code>&quot;ES2016&quot;</code>或更高</li></ul></li><li><code>target</code>指的是<strong>要編譯的目標javascript版本</strong><blockquote><p>ES3, ES5, ES6 之類的</p></blockquote></li><li><code>module</code>指的是<strong>要編譯的目標javascript模組樣式</strong><blockquote><p>require(‘xxx’) 或 import xxx from ‘xxx’</p></blockquote></li><li><code>target</code>與<code>module</code>跟Typescript怎麼寫無關，只跟編譯出來的javascript有關</li></ul><hr><h2 id="Day-32-戰線擴張・專案輸出-X-輸出設定-TypeScript-Compiler-Output-Configurations"><a href="#Day-32-戰線擴張・專案輸出-X-輸出設定-TypeScript-Compiler-Output-Configurations" class="headerlink" title="Day 32. 戰線擴張・專案輸出 X 輸出設定 - TypeScript Compiler Output Configurations"></a><a href="https://ithelp.ithome.com.tw/articles/10222307">Day 32. 戰線擴張・專案輸出 X 輸出設定 - TypeScript Compiler Output Configurations</a></h2><ul><li><code>rootDir</code>是原始碼所在的位置<blockquote><p>通常為”./src”</p></blockquote></li><li><code>outDir</code>是執行tsc後，編譯出來的javascript的位置<blockquote><p>通常為”./build”</p></blockquote></li><li>就算有原始碼沒有放在<code>rootDir</code>設定的目錄，tsc也一樣會試圖編譯，但是會產生奇怪的目錄結構<br>  <img src=":/08b0ef7c6624485398a1d8737c72b5c1" alt="a7ee9eadba4f1d8450cb62b0a5e01ab9.png"></li><li>為了避免上述的狀況，可以在tsconfig.json設定  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;noEmitOnError&quot;: true</span><br></pre></td></tr></table></figure>  使得tsc在遇到錯誤的時候不會輸出任何檔案</li><li><code>rootDirs </code>可以設定多個專案目錄</li><li><code>outFile</code>可以打包成單個檔案，但是有<code>module</code>的限制<ul><li>不受<code>outDir</code>影響</li></ul></li></ul><hr><h2 id="Day-33-戰線擴張・專案除錯-X-源碼對照-TypeScript-Compiler-Debug-Techniques"><a href="#Day-33-戰線擴張・專案除錯-X-源碼對照-TypeScript-Compiler-Debug-Techniques" class="headerlink" title="Day 33. 戰線擴張・專案除錯 X 源碼對照 - TypeScript Compiler Debug Techniques"></a><a href="https://ithelp.ithome.com.tw/articles/10223348">Day 33. 戰線擴張・專案除錯 X 源碼對照 - TypeScript Compiler Debug Techniques</a></h2><h3 id="使用lite-server建立一個簡易的環境"><a href="#使用lite-server建立一個簡易的環境" class="headerlink" title="使用lite-server建立一個簡易的環境"></a>使用lite-server建立一個簡易的環境</h3><p>lite-server是個簡易的網頁伺服器，具有以下特色</p><ul><li>自動開啟網頁</li><li>當原始碼變更時，網頁會自動更新</li><li>待補…</li></ul><ol><li>安裝lite-server <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i lite-server --save-dev</span><br></pre></td></tr></table></figure></li><li>加入dev，讓npm執行lite-server<br>package.json <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 略... */</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;lite-server&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 略... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sourceMap&quot;: true</span><br></pre></td></tr></table></figure><h3 id="除錯技巧"><a href="#除錯技巧" class="headerlink" title="除錯技巧"></a>除錯技巧</h3></li><li> [JS][TS]<code>debugger</code>關鍵字<br>在執行到<code>debugger;</code>的時候，將會自動中斷</li><li>[JS]在瀏覽器的除錯工具設中斷<br> <img src=":/b4e54275ce7d49dd970938dbf550ab6d" alt="c402b13341edfad163d0404baf0d02fa.png"></li><li>[TS]使用sourceMap<br> tsconfig.json <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"><span class="comment">/* 略... */</span></span><br><span class="line"><span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment">/* 略... */</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 一樣在瀏覽器設定中斷<br> <img src=":/98326375dc894d70aa45a87ca3e9c563" alt="3fc1049317e82bfa13e5431e6a1942a1.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-28</title>
      <link href="/Note/2020/12/27/Learning%20Typescript%202020-12-28/"/>
      <url>/Note/2020/12/27/Learning%20Typescript%202020-12-28/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-29-機動藍圖・工廠模式-X-抽象工廠-Factory-Method-amp-Abstract-Factory-Pattern-Using-TypeScript"><a href="#Day-29-機動藍圖・工廠模式-X-抽象工廠-Factory-Method-amp-Abstract-Factory-Pattern-Using-TypeScript" class="headerlink" title="Day 29. 機動藍圖・工廠模式 X 抽象工廠 - Factory Method &amp; Abstract Factory Pattern Using TypeScript"></a><a href="https://ithelp.ithome.com.tw/articles/10221353">Day 29. 機動藍圖・工廠模式 X 抽象工廠 - Factory Method &amp; Abstract Factory Pattern Using TypeScript</a></h2><p>本章介紹簡單工廠模式&amp;抽象工廠模式</p><ol><li>簡單工廠模式<blockquote><p>建立一個藉由參數來指定生產什麼的類別<br><strong>比抽象類別易於使用, 但擴充性有限</strong><br><strong>適用於快速開發，不需要複雜功能的狀況</strong></p></blockquote></li><li>抽象工廠模式<blockquote><p>將工廠抽象化, 使得工廠可以被重複利用<br><strong>比簡單工廠模式更有彈性, 但需要建立很多抽象界面/類別</strong><br><strong>適用於大型專案，未來需要持續擴充的狀況</strong></p></blockquote></li></ol><p>感覺可以讓策略模式跟抽象工廠結合？</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-25</title>
      <link href="/Note/2020/12/24/Learning%20Typescript%202020-12-25/"/>
      <url>/Note/2020/12/24/Learning%20Typescript%202020-12-25/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-28-機動藍圖・抽象類別-X-藍圖基底-TypeScript-Abstract-Class"><a href="#Day-28-機動藍圖・抽象類別-X-藍圖基底-TypeScript-Abstract-Class" class="headerlink" title="Day 28. 機動藍圖・抽象類別 X 藍圖基底 - TypeScript Abstract Class"></a><a href="https://ithelp.ithome.com.tw/articles/10219198">Day 28. 機動藍圖・抽象類別 X 藍圖基底 - TypeScript Abstract Class</a></h2><p>接續上一篇文章的內容, 本篇目標在於將攻擊方法移入Weapon中<br>但是, 卻因爲重複以下程式碼,而違反DRY(Don’t Repeat Yourself)原則</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">WeaponStrategy</span> <span class="title">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">switchAttackStrategy</span>(<span class="params"><span class="keyword">type</span>: Attack</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.attackStrategy = <span class="keyword">type</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">attack</span>(<span class="params">self: Character, target: Character</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.attackStrategy.attack(self, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一個解法是把Weapon改爲class, 但是, 改爲class會造成靈活度降低, 因此, 可以改爲抽象類別<code>abstract class</code><br>抽象類別雖然是類別，但跟interface一樣，還是屬於抽象的概念，但介於兩者之間，可以袃抽象類別中預先填入函數、屬性，也可以讓其他class綁定(<code>implements</code>)</p><p>抽象類別的限制 Limitation of Abstract Class：</p><ol><li>抽象類別不能建立物件(因爲還是抽象)</li><li>根據前一點推斷: 抽象類別生來就是要被繼承的</li><li>抽象類別裡的抽象成員（Abstract Member），由於要滿足介面的特性 —— 代表規格並且強迫繼承的子類別必須實踐功能，因此抽象成員必需被實踐為 public 模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-24</title>
      <link href="/Note/2020/12/23/Learning%20Typescript%202020-12-24/"/>
      <url>/Note/2020/12/23/Learning%20Typescript%202020-12-24/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-26-機動藍圖・策略模式-X-選擇策略-Strategy-Pattern-Using-TypeScript-I"><a href="#Day-26-機動藍圖・策略模式-X-選擇策略-Strategy-Pattern-Using-TypeScript-I" class="headerlink" title="Day 26. 機動藍圖・策略模式 X 選擇策略 - Strategy Pattern Using TypeScript. I"></a><a href="https://ithelp.ithome.com.tw/articles/10220356">Day 26. 機動藍圖・策略模式 X 選擇策略 - Strategy Pattern Using TypeScript. I</a></h2><h2 id="Day-27-機動藍圖・策略模式-X-臨機應變-Strategy-Pattern-Using-TypeScript-II"><a href="#Day-27-機動藍圖・策略模式-X-臨機應變-Strategy-Pattern-Using-TypeScript-II" class="headerlink" title="Day 27. 機動藍圖・策略模式 X 臨機應變 - Strategy Pattern Using TypeScript. II"></a><a href="https://ithelp.ithome.com.tw/articles/10220710">Day 27. 機動藍圖・策略模式 X 臨機應變 - Strategy Pattern Using TypeScript. II</a></h2><p>在學會策略模式之前,有兩個做法,switch或是新增一堆界面及類別, 但是, 這樣最後會變得很亂</p><p>策略模式類似於enum的用法,新增一個enum在父類別,由子類別來變更<br>Attack.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Attack&#123;</span><br><span class="line">attack(self: Character, <span class="attr">target</span>: Character): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Character.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span></span>&#123;</span><br><span class="line"><span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params"> <span class="keyword">public</span> <span class="keyword">readonly</span> name: striug,</span></span><br><span class="line"><span class="params"> <span class="keyword">public</span> <span class="keyword">readonly</span> role: Role,</span></span><br><span class="line"><span class="params"> <span class="keyword">private</span> attackRef: Attack,</span></span><br><span class="line"><span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">attack</span>(<span class="params">target: Character</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.attackRef.attack(<span class="built_in">this</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hi, I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> the <span class="subst">$&#123;<span class="built_in">this</span>.role&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MeleeAttack.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MeleeAttack</span> <span class="title">implements</span> <span class="title">Attacl</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">attack</span>(<span class="params">self: Character, target: Character</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;self.name&#125;</span> strikes <span class="subst">$&#123;target.name&#125;</span> with a big sword!`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MagicAttack.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicAttack</span> <span class="title">implements</span> <span class="title">Acttack</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">attack</span>(<span class="params">self: Character, target: Charactor</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;self.name&#125;</span> casts magic and pierces through <span class="subst">$&#123;target.name&#125;</span>!`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Warlock.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Warlock</span> <span class="keyword">extends</span> <span class="title">Character</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(</span><br><span class="line">name,</span><br><span class="line">Role.Warlock,</span><br><span class="line"><span class="keyword">new</span> MagicAttack()</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意attackRef, 他類似於一個tag,但是, attackRef相比enum, 可以包含更多資訊</li></ul><h2 id="Changing-algorithm-during-runtime"><a href="#Changing-algorithm-during-runtime" class="headerlink" title="Changing algorithm during runtime."></a>Changing algorithm during runtime.</h2><blockquote><p>即”在執行的時候變更策略”</p></blockquote><p>這是策略模式跟先前所學最大的不同, 舉例來說, 如果攻擊方法有很多種, 需要有切換的功能</p><p>Character.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">SwitchAttackStrategy</span>(<span class="params"><span class="keyword">type</span>: Attack</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.attackRef = <span class="keyword">type</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要隨着武器不同而變化…<br>步驟 1. 策略的介面綁定與宣告<br>Weapon.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> Weapon &#123;</span><br><span class="line"><span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">abailableRoles: Role[];</span><br><span class="line">attackStrareggy: Attack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BasicSword.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSword</span> <span class="title">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> name = <span class="string">&#x27;Basic Sword&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> attackStrategy = <span class="keyword">new</span> MeleeAttack();</span><br><span class="line"><span class="keyword">public</span> availableRoles = &#123;</span><br><span class="line">Role.Swordsman,</span><br><span class="line">Role.Highwayman</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步驟 2. 父類別建立策略參考點</p><p>Character.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> attackRef: Attack;</span><br><span class="line"><span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params"> <span class="keyword">public</span> <span class="keyword">readonly</span> role: Role,</span></span><br><span class="line"><span class="params"> <span class="keyword">private</span> weaponRef: Weapon,</span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.attackRef = <span class="built_in">this</span>.weaponRef.attackStrategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">attack</span>(<span class="params">target: Character</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.attackRef.attack(<span class="built_in">this</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">equip</span>(<span class="params">weapon: Weapon</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">availableRoles</span>: roles &#125; = weapon;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">roles.length === <span class="number">0</span> || roles.indesOf(<span class="built_in">this</span>.role) !== -<span class="number">1</span></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> has equipped <span class="subst">$&#123;weapon.name&#125;</span>!`</span>);</span><br><span class="line"><span class="built_in">this</span>.weaponRef = ewapon;</span><br><span class="line"><span class="built_in">this</span>.attackRef - <span class="built_in">this</span>.weaponRef.attackStrategy;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.role&#125;</span> cannot equip <span class="subst">$&#123;weapon.name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-23</title>
      <link href="/Note/2020/12/22/Learning%20Typescript%202020-12-23/"/>
      <url>/Note/2020/12/22/Learning%20Typescript%202020-12-23/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-25-機動藍圖・類別與介面-X-終極的組合-Ultimate-Combo-of-Class-amp-Interface"><a href="#Day-25-機動藍圖・類別與介面-X-終極的組合-Ultimate-Combo-of-Class-amp-Interface" class="headerlink" title="Day 25. 機動藍圖・類別與介面 X 終極的組合 - Ultimate Combo of Class &amp; Interface"></a><a href="https://ithelp.ithome.com.tw/articles/10219927">Day 25. 機動藍圖・類別與介面 X 終極的組合 - Ultimate Combo of Class &amp; Interface</a></h2><ol><li>先把介面宣告出來，確認規格（Speculation，時常被簡短為 Spec.）</li><li>將類別對介面進行綁定</li><li>類別必須實踐介面規範的規格</li></ol><ul><li>冗長的 switch…case… 敘述式的解法中 —— 其中一種就是使用 Strategy Pattern （策略模式）來解掉</li></ul><h2 id="類別繼承與介面綁定最大的不同-Class-Inheritance-V-S-Interface-Implementation"><a href="#類別繼承與介面綁定最大的不同-Class-Inheritance-V-S-Interface-Implementation" class="headerlink" title="類別繼承與介面綁定最大的不同 Class Inheritance V.S. Interface Implementation"></a>類別繼承與介面綁定最大的不同 Class Inheritance V.S. Interface Implementation</h2><p>兩個系統的耦合程度（Coupling）中，使用類別繼承的耦合程度一定會比介面的綁定還來得高。</p><p>在父類別新增一個功能跟嵌入一個介面比起來，後者的難度會比較低。父類別要是新增一項功能，則必須確保所有的子類別能夠正常運作，否則會面臨到所有的子類別為了遷就父類別新增的功能必須進行覆寫的動作；另外，如果想要將父類別裡面的某些功能抽出來給其他程式碼或類別使用實在是不容易的事情。</p><p>嵌入介面是比較保險版本的新增功能方式，而且介面是可以被不同類別重複利用，不會像類別死死地把成員細節絕對綁定。除非類別跟父類別間的關係程度真的是很緊密，可以使用繼承，否則通常會使用介面來組出功能。</p><p>然而，OOP 設計模式裡，當然不侷限於使用介面的方式降低耦合程度，善用類別物件組織起來（Object Composition）而不使用類別繼承也可以達到降低相依的耦合度，這些都算是軟體江湖上流傳的招式 —— 筆者將在第 30 天揭曉。（不過講到策略模式時，就會讓讀者體會到不需經由類別繼承就可以達到耦合度的降低！聽起來很好吃！）</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-22</title>
      <link href="/Note/2020/12/21/Learning%20Typescript%202020-12-22/"/>
      <url>/Note/2020/12/21/Learning%20Typescript%202020-12-22/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-24-機動藍圖・類別推論-X-註記類別-Class-Type-Inference-amp-Annotation"><a href="#Day-24-機動藍圖・類別推論-X-註記類別-Class-Type-Inference-amp-Annotation" class="headerlink" title="Day 24. 機動藍圖・類別推論 X 註記類別 - Class Type Inference &amp; Annotation"></a><a href="https://ithelp.ithome.com.tw/articles/10219657">Day 24. 機動藍圖・類別推論 X 註記類別 - Class Type Inference &amp; Annotation</a></h2><ul><li>只要類別或類型沒有public以外的(private, protected)屬性及函數,只要格式一模ㄧ樣,都可以被等效  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TA = &#123; <span class="attr">hello</span>: <span class="built_in">string</span>&#125;;</span><br><span class="line"><span class="keyword">type</span> TB = &#123; <span class="attr">hello</span>: <span class="built_in">string</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IA &#123;</span><br><span class="line">hello: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IB &#123;</span><br><span class="line">hello: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logTypeA</span>(<span class="params">obj: TA</span>) </span>&#123; <span class="built_in">console</span>.log(obj); &#125;</span><br><span class="line"></span><br><span class="line">logTypeA(&lt;TA&gt;&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br><span class="line">logTypeA(&lt;TB&gt;&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br><span class="line">logTypeA(&lt;IA&gt;&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br><span class="line">logTypeA(&lt;IA&gt;&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>  這個例子不會出現錯誤訊息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-21</title>
      <link href="/Note/2020/12/20/Learning%20Typescript%202020-12-21/"/>
      <url>/Note/2020/12/20/Learning%20Typescript%202020-12-21/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-22-機動藍圖・特殊成員-X-存取方法-TypeScript-Class-Accessors"><a href="#Day-22-機動藍圖・特殊成員-X-存取方法-TypeScript-Class-Accessors" class="headerlink" title="Day 22. 機動藍圖・特殊成員 X 存取方法 - TypeScript Class Accessors"></a><a href="https://ithelp.ithome.com.tw/articles/10218638">Day 22. 機動藍圖・特殊成員 X 存取方法 - TypeScript Class Accessors</a></h2><ul><li>在建構子裡面進行運算事實上是不建議的，因為建構子的目的是初始化物件的成員變數們</li><li>Access修飾詞有get與set</li><li>get皆爲readonly</li><li>get不能有參數,set只能有1個,不能多不能少<br><a href="https://ithelp.ithome.com.tw/articles/10218770">Day 23. 機動藍圖・私有建構子 X 單身狗模式 - Private Constructor &amp; Singleton Pattern</a></li><li>可以利用private constructor建立單列模式的class  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonPerson</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> age: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> hasPet: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Instance: SingletonPerson =<span class="keyword">new</span> SingletonPerson(<span class="string">&#x27;Maxwell&#x27;</span>, <span class="number">20</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> getInstance(): SingletonPerson &#123; <span class="keyword">return</span> <span class="built_in">this</span>.Instance; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>單例模式即爲只建立單一實例,並不允許自行建立</li><li>單一實例需要注意多執行續的問題(Node.js因爲V8引擎的關係,只有單執行續)</li><li>可以繼承自單例模式的父類別,並讓子類別可以隨時抽換</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Typescript 2020-12-18</title>
      <link href="/Note/2020/12/17/Learning%20Typescript%202020-12-18/"/>
      <url>/Note/2020/12/17/Learning%20Typescript%202020-12-18/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-21-機動藍圖・靜態成員-X-即刻操作-Static-Properties-amp-Methods"><a href="#Day-21-機動藍圖・靜態成員-X-即刻操作-Static-Properties-amp-Methods" class="headerlink" title="Day 21. 機動藍圖・靜態成員 X 即刻操作 - Static Properties &amp; Methods"></a><a href="">Day 21. 機動藍圖・靜態成員 X 即刻操作 - Static Properties &amp; Methods</a></h2><ul><li>一個interface一個功能, 儘量用綁定介面或繼承的,而不是直接添加屬性或函數,此爲物件導向(OOP)</li></ul><ol><li>子類別無法存取父類別有<code>private</code>與<code>Mprivate</code>修飾詞的屬性或函數</li><li>如果不要讓子類別以外的類別存取,可以標示爲<code>protected </code></li><li>類別自類別繼承使用extend</li><li>界面綁定介面用<code>implements</code></li><li>interface可以綁定(<code>implements</code>)多個interface</li><li>class可以綁定(<code>implements</code>)多個interface,但只能繼承(<code>extend</code>)一個class</li></ol>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How to use NodeJs with Typescript and ESM module</title>
      <link href="/Note/2020/11/13/How%20to%20use%20NodeJs%20with%20Typescript%20and%20ESM%20module/"/>
      <url>/Note/2020/11/13/How%20to%20use%20NodeJs%20with%20Typescript%20and%20ESM%20module/</url>
      
        <content type="html"><![CDATA[<h2 id="各元件介紹"><a href="#各元件介紹" class="headerlink" title="各元件介紹"></a>各元件介紹</h2><p>先介紹各個元件是什麼</p><ol><li>vscode(Visual Studio Code)：多功能的IDE</li><li>npm：套件管理工具？(目前認知是這樣，後續補充)</li><li>nodemon：監視原始碼是否有變更，有變更則依照腳本自動重新啟動</li><li>node.js；採用V8引擎讓Javascript成為後端語言的強大開發工具</li><li>typescript：由Microsoft主導，將Javascript加入強型別特性的新語言，一般需要將.ts檔案藉由typescript編譯為.js，讓瀏覽器或Node.js能夠辨識</li><li>ts-node：讓typescript檔案無須編譯為.js檔案，即可直接使用.ts檔</li></ol><p>Node.js原生是沒有支援Typescript的，並且在14版才正式以ESM取代CSM，因此網路上到處都是CSM的教學，是Typescript且是ESM的文章稀少，初學Node.js的我為此燒透了腦</p><p>VSCode提供一個方便的除錯器讓開發者除錯，但要怎麼把這6個東西串再一起呢？</p><h2 id="順序流程"><a href="#順序流程" class="headerlink" title="順序流程"></a>順序流程</h2><ol><li>vscode啟動nodemon</li><li>依照nodemon.json所寫的內容，自動透過npm執行node.js</li><li>node.js載入ts-node</li><li>ts-node會自動使用typescript去動態的編譯.ts檔案並且執行(這個寫在套件裡，我們不用去管)</li></ol><hr><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><ul><li>Node.js 14</li><li>ts-node &gt;= 9.0</li><li>nodemon &gt;= 2.0.6</li></ul><ol><li><p>安裝套件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/TypeStrong/ts-node</span><br><span class="line">npm install nodemon</span><br><span class="line">npm install typescript</span><br><span class="line">npm install @types/node</span><br></pre></td></tr></table></figure><p>install ts-node from github is because of author had fix some issue on github but npm(2020.11.15)</p></li><li><p>在launch.json的configurations添加</p> <figure class="highlight json"><figcaption><span>launch.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pwa-node&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Server&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;restart&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;runtimeArgs&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;run&quot;</span>,</span><br><span class="line">                <span class="string">&quot;start:watch&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;skipFiles&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;&lt;node_internals&gt;/**&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json添加三個npm的腳本</p> <a name="package.json"> <figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">        <span class="comment">// reference from [this](https://github.com/TypeStrong/ts-node/issues/1007) issue to add a experimental arg</span></span><br><span class="line">        <span class="comment">// add --experimental-specifier-resolution=node to let node ignore extension filename</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node --loader ts-node/esm --experimental-specifier-resolution=node ./app.ts&quot;</span>,</span><br><span class="line">        <span class="comment">// use nodemon to debug.nodemon.json is the config of nodemon </span></span><br><span class="line">        <span class="attr">&quot;start:watch&quot;</span>: <span class="string">&quot;nodemon&quot;</span>,</span><br><span class="line">        <span class="comment">// build typescript project to javascript</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;tsc&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Note: scripts is using when someone call npm and add args like <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>在根目錄新增nodemon.json，並填入會用到的參數</p> <figure class="highlight json"><figcaption><span>nodemon.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ignore&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;.git&quot;</span>,</span><br><span class="line">        <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">        <span class="string">&quot;**/*.test.ts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;**/*.spec.ts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">        <span class="string">&quot;temp&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;exec&quot;</span>: <span class="string">&quot;npm start&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ext&quot;</span>: <span class="string">&quot;ts,js,json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 各節點的作用如下：</p><ul><li>“ignore”: ignore中的目錄就算變更了，debug也不會熱重啟</li><li>“watch”: 監視除了ignore以外的所有目錄與檔案，如果有變更則熱重啟伺服器</li><li>“exec”: 當執行nodemon後，接下來會進行的動作<br>這邊是告訴nodemon要執行<a href="#package.json">package.json</a>的start</li><li>“ext:” 監視這三種副檔名的檔案</li></ul></li><li><p>tsconfig.json</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2020&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;esNext&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lib&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;ES2020&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;app.ts&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因為ts-node會把.ts編譯為.js，所以”allowJs”必須要開啟</li><li>主要參考自ts-node作者的<a href="https://github.com/TypeStrong/ts-node/issues/1007">issue</a></li><li>重點在於<code>lib</code>必須添加”ES2015”以上的lib，以添加Promise等功能</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> nodemon </tag>
            
            <tag> Node.js </tag>
            
            <tag> Typescript </tag>
            
            <tag> ts-node </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
